--- a/bashline.c
+++ b/bashline.c
@@ -1311,8 +1311,9 @@
 find_cmd_start (start)
      int start;
 {
-  register int s, os, ns;
+  register int s, os, ns, last;
 
+  last = 0;
   os = 0;
   /* Flags == SD_NOJMP only because we want to skip over command substitutions
      in assignment statements.  Have to test whether this affects `standalone'
@@ -1330,7 +1331,13 @@
 	  continue;
 	}
       os = s+1;
+      last = s;
     }
+  /* If the last seperator is a pipe keep it at the beginning of the command. The
+     pipe character is a command seperator and a command. */
+  if (rl_line_buffer[last] == '|')
+    os = last;
+
   return os;
 }
 
@@ -1350,13 +1357,18 @@
      int *sp, *ep;
 {
   char *name;
-  register int s, e;
+  register int s, s1, e;
 
   for (s = start; whitespace (rl_line_buffer[s]); s++)
     ;
 
+  /* If first character is a pipe char scan from next char */
+  s1 = s;
+  if (rl_line_buffer[s] == '|')
+    ++s1;
+
   /* skip until a shell break character */
-  e = skip_to_delim (rl_line_buffer, s, "()<>;&| \t\n", SD_NOJMP|SD_COMPLETE);
+  e = skip_to_delim (rl_line_buffer, s1, "()<>;&| \t\n", SD_NOJMP|SD_COMPLETE);
 
   name = substring (rl_line_buffer, s, e);
 
@@ -1423,6 +1435,7 @@
   int in_command_position, ti, saveti, qc, dflags;
   char **matches, *command_separator_chars;
 #if defined (PROGRAMMABLE_COMPLETION)
+  COMPSPEC *cs;
   int have_progcomps, was_assignment;
 #endif
 
@@ -1482,6 +1495,11 @@
 	 that all of the previous words on the line are variable
 	 assignments. */
     }
+#if defined (PROGRAMMABLE_COMPLETION)
+  cs = progcomp_search(DEFAULTCMD);
+  if (cs && cs->options & COPT_NOFIRSTWORD)
+    in_command_position = 0;
+#endif /* PROGRAMMABLE_COMPLETION */
 
   if (in_command_position && invalid_completion (text, ti))
     {
@@ -1569,12 +1587,20 @@
 	{
 	  /* not assignment statement, but still want to perform command
 	     completion if we are composing command word. */
-	  foundcs = 0;
-	  in_command_position = s == start && STREQ (n, text);	/* XXX */
+	  if (cs && cs->options & COPT_NOFIRSTWORD)
+	    prog_complete_matches = programmable_completions (EMPTYCMD, text, s, e, &foundcs);
+	  else
+	    {
+	      foundcs = 0;
+	      in_command_position = s == start && STREQ (n, text);	/* XXX */
+	    }
 	}
       else if (e > s && was_assignment == 0 && have_progcomps)
 	{
-	  prog_complete_matches = programmable_completions (n, text, s, e, &foundcs);
+          if (n[0] == '|' && cs && cs->options & COPT_NOFIRSTWORD)
+            prog_complete_matches = programmable_completions (EMPTYCMD, text, s, e, &foundcs);
+          else
+            prog_complete_matches = programmable_completions (n, text, s, e, &foundcs);
 	  /* command completion if programmable completion fails */
 	  in_command_position = s == start && STREQ (n, text);	/* XXX */
 	}
@@ -1582,8 +1608,13 @@
       else if (s >= e && n[0] == '\0' && text[0] == '\0' && start > 0 &&
 		was_assignment == 0 && member (rl_line_buffer[start-1], COMMAND_SEPARATORS))
 	{
-	  foundcs = 0;
-	  in_command_position = 1;
+          if (cs && cs->options & COPT_NOFIRSTWORD)
+            prog_complete_matches = programmable_completions (EMPTYCMD, text, s, e, &foundcs);
+          else
+            {
+             foundcs = 0;	/* empty command name following assignments */
+              in_command_position = was_assignment;
+            }
 	}
       else if (s >= e && n[0] == '\0' && text[0] == '\0' && start > 0)
         {
--- a/builtins/complete.def
+++ b/builtins/complete.def
@@ -141,6 +141,7 @@
   { "nosort", COPT_NOSORT },
   { "nospace",	COPT_NOSPACE },
   { "plusdirs", COPT_PLUSDIRS },
+  { "nofirstword", COPT_NOFIRSTWORD },
   { (char *)NULL, 0 },
 };
 
@@ -517,6 +518,7 @@
   PRINTCOMPOPT (COPT_FILENAMES, "filenames");
   PRINTCOMPOPT (COPT_NOSPACE, "nospace");
   PRINTCOMPOPT (COPT_PLUSDIRS, "plusdirs");
+  PRINTCOMPOPT (COPT_NOFIRSTWORD, "nofirstword");
 
   acts = cs->actions;
 
@@ -591,6 +593,7 @@
       XPRINTCOMPOPT (COPT_FILENAMES, "filenames");
       XPRINTCOMPOPT (COPT_NOSPACE, "nospace");
       XPRINTCOMPOPT (COPT_PLUSDIRS, "plusdirs");
+      XPRINTCOMPOPT (COPT_NOFIRSTWORD, "nofirstword");
     }
   else
     {
@@ -600,6 +603,7 @@
       PRINTCOMPOPT (COPT_FILENAMES, "filenames");
       PRINTCOMPOPT (COPT_NOSPACE, "nospace");
       PRINTCOMPOPT (COPT_PLUSDIRS, "plusdirs");
+      PRINTCOMPOPT (COPT_NOFIRSTWORD, "nofirstword");
     }
 
   if (STREQ (cmd, EMPTYCMD))
--- a/pcomplete.h
+++ b/pcomplete.h
@@ -76,6 +76,8 @@
 #define COPT_BASHDEFAULT (1<<6)
 #define COPT_PLUSDIRS	(1<<7)
 #define COPT_NOSORT	(1<<8)
+#define COPT_NOFIRSTWORD (1<<9)
+
 
 /* List of items is used by the code that implements the programmable
    completions. */
