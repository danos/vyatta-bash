Description: Add -I option to compopt and complete for custom cmd completion
 User-supplied programmable completion with the -I option can be used
 to customise command completion.
Origin: http://git.savannah.gnu.org/cgit/bash.git/commit/?h=devel&id=12beeabf52074f1061d8c12f0a1b57a743510b17
--- a/bashline.c
+++ b/bashline.c
@@ -1437,6 +1437,7 @@ attempt_shell_completion (text, start, e
 #if defined (PROGRAMMABLE_COMPLETION)
   COMPSPEC *cs;
   int have_progcomps, was_assignment;
+  COMPSPEC *iw_compspec;
 #endif
 
   command_separator_chars = COMMAND_SEPARATORS;
@@ -1526,7 +1527,9 @@ attempt_shell_completion (text, start, e
 #if defined (PROGRAMMABLE_COMPLETION)
   /* Attempt programmable completion. */
   have_progcomps = prog_completion_enabled && (progcomp_size () > 0);
-  if (matches == 0 && (in_command_position == 0 || text[0] == '\0') &&
+  iw_compspec = progcomp_search (INITIALWORD);
+  if (matches == 0 &&
+      (in_command_position == 0 || text[0] == '\0' || (in_command_position && iw_compspec)) &&
       current_prompt_string == ps1_prompt)
     {
       int s, e, s1, e1, os, foundcs;
@@ -1602,7 +1605,10 @@ attempt_shell_completion (text, start, e
           else
             prog_complete_matches = programmable_completions (n, text, s, e, &foundcs);
 	  /* command completion if programmable completion fails */
-	  in_command_position = s == start && STREQ (n, text);	/* XXX */
+	  /* If we have a completion for the initial word, we can prefer that */
+	  in_command_position = s == start && (iw_compspec || STREQ (n, text));	/* XXX */
+	  if (iw_compspec && in_command_position)
+	    foundcs = 0;
 	}
       /* empty command name following command separator */
       else if (s >= e && n[0] == '\0' && text[0] == '\0' && start > 0 &&
@@ -1618,8 +1624,8 @@ attempt_shell_completion (text, start, e
 	}
       else if (s >= e && n[0] == '\0' && text[0] == '\0' && start > 0)
         {
-          foundcs = 0;	/* empty command name following assignments */
-          in_command_position = was_assignment;
+          foundcs = 0;	/* empty command name following optional assignments */
+          in_command_position += was_assignment;
         }
       else if (s == start && e == end && STREQ (n, text) && start > 0)
         {
@@ -1628,6 +1634,12 @@ attempt_shell_completion (text, start, e
         }
       else
 	foundcs = 0;
+
+      /* If we have defined a compspec for the initial (command) word, call
+	 it and process the results like any other programmable completion. */
+      if (in_command_position && have_progcomps && foundcs == 0 && iw_compspec)
+	prog_complete_matches = programmable_completions (INITIALWORD, text, s, e, &foundcs);
+
       FREE (n);
       /* XXX - if we found a COMPSPEC for the command, just return whatever
 	 the programmable completion code returns, and disable the default
--- a/builtins/complete.def
+++ b/builtins/complete.def
@@ -23,7 +23,7 @@ $PRODUCES complete.c
 $BUILTIN complete
 $DEPENDS_ON PROGRAMMABLE_COMPLETION
 $FUNCTION complete_builtin
-$SHORT_DOC complete [-abcdefgjksuv] [-pr] [-DE] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]
+$SHORT_DOC complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]
 Specify how arguments are to be completed by Readline.
 
 For each NAME, specify how arguments are to be completed.  If no options
@@ -38,10 +38,12 @@ Options:
 		without any specific completion defined
   -E	apply the completions and actions to "empty" commands --
 		completion attempted on a blank line
+  -I	apply the completions and actions to the intial (usually the
+		command) word
 
 When completion is attempted, the actions are applied in the order the
-uppercase-letter options are listed above.  The -D option takes
-precedence over -E.
+uppercase-letter options are listed above.  If multiple options are supplied,
+the -D option takes precedence over -E, and both take precedence over -I.
 
 Exit Status:
 Returns success unless an invalid option is supplied or an error occurs.
@@ -79,6 +81,7 @@ struct _optflags {
   int rflag;
   int Dflag;
   int Eflag;
+  int Iflag;
 };
 
 static int find_compact __P((char *));
@@ -196,7 +199,7 @@ build_actions (list, flagp, actp, optp)
   opt_given = 0;
 
   reset_internal_getopt ();
-  while ((opt = internal_getopt (list, "abcdefgjko:prsuvA:G:W:P:S:X:F:C:DE")) != -1)
+  while ((opt = internal_getopt (list, "abcdefgjko:prsuvA:G:W:P:S:X:F:C:DEI")) != -1)
     {
       opt_given = 1;
       switch (opt)
@@ -308,6 +311,18 @@ build_actions (list, flagp, actp, optp)
 	      builtin_usage ();
 	      return (EX_USAGE);
 	    }
+	case 'I':
+	  if (flagp)
+	    {
+	      flagp->Iflag = 1;
+	      break;
+	    }
+	  else
+	    {
+	      sh_invalidopt ("-I");
+	      builtin_usage ();
+	      return (EX_USAGE);
+	    }
 	case 'F':
 	  Farg = list_optarg;
 	  break;
@@ -356,7 +371,8 @@ complete_builtin (list)
       return (EXECUTION_SUCCESS);
     }
 
-  opt_given = oflags.pflag = oflags.rflag = oflags.Dflag = oflags.Eflag = 0;
+  opt_given = oflags.pflag = oflags.rflag = 0;
+  oflags.Dflag = oflags.Eflag = oflags.Iflag = 0;
 
   acts = copts = (unsigned long)0L;
   Garg = Warg = Parg = Sarg = Xarg = Farg = Carg = (char *)NULL;
@@ -371,8 +387,14 @@ complete_builtin (list)
 
   list = loptend;
 
-  wl = oflags.Dflag ? make_word_list (make_bare_word (DEFAULTCMD), (WORD_LIST *)NULL)
-  		    : (oflags.Eflag ? make_word_list (make_bare_word (EMPTYCMD), (WORD_LIST *)NULL) : 0);
+  if (oflags.Dflag)
+    wl = make_word_list (make_bare_word (DEFAULTCMD), (WORD_LIST *)NULL);
+  else if (oflags.Eflag)
+    wl = make_word_list (make_bare_word (EMPTYCMD), (WORD_LIST *)NULL);
+  else if (oflags.Iflag)
+    wl = make_word_list (make_bare_word (INITIALWORD), (WORD_LIST *)NULL);
+  else
+    wl = (WORD_LIST *)NULL;
 
   /* -p overrides everything else */
   if (oflags.pflag || (list == 0 && opt_given == 0))
@@ -564,10 +586,12 @@ print_one_completion (cmd, cs)
   /* simple arguments that don't require quoting */
   PRINTARG (cs->funcname, "-F");
 
-  if (STREQ (cmd, EMPTYCMD))
-    printf ("-E\n");
-  else if (STREQ (cmd, DEFAULTCMD))
+  if (STREQ (cmd, DEFAULTCMD))
     printf ("-D\n");
+  else if (STREQ (cmd, EMPTYCMD))
+    printf ("-E\n");
+  else if (STREQ (cmd, INITIALWORD))
+    printf ("-I\n");
   else
     printf ("%s\n", cmd);
 
@@ -606,10 +630,12 @@ print_compopts (cmd, cs, full)
       PRINTCOMPOPT (COPT_NOFIRSTWORD, "nofirstword");
     }
 
-  if (STREQ (cmd, EMPTYCMD))
-    printf ("-E\n");
-  else if (STREQ (cmd, DEFAULTCMD))
+  if (STREQ (cmd, DEFAULTCMD))
     printf ("-D\n");
+  else if (STREQ (cmd, EMPTYCMD))
+    printf ("-E\n");
+  else if (STREQ (cmd, INITIALWORD))
+    printf ("-I\n");
   else
     printf ("%s\n", cmd);
 }
@@ -757,7 +783,7 @@ compgen_builtin (list)
 $BUILTIN compopt
 $DEPENDS_ON PROGRAMMABLE_COMPLETION
 $FUNCTION compopt_builtin
-$SHORT_DOC compopt [-o|+o option] [-DE] [name ...]
+$SHORT_DOC compopt [-o|+o option] [-DEI] [name ...]
 Modify or display completion options.
 
 Modify the completion options for each NAME, or, if no NAMEs are supplied,
@@ -768,6 +794,7 @@ Options:
 	-o option	Set completion option OPTION for each NAME
 	-D		Change options for the "default" command completion
 	-E		Change options for the "empty" command completion
+	-I		Change options for completion on the initial word
 
 Using `+o' instead of `-o' turns off the specified option.
 
@@ -788,15 +815,15 @@ int
 compopt_builtin (list)
      WORD_LIST *list;
 {
-  int opts_on, opts_off, *opts, opt, oind, ret, Dflag, Eflag;
+  int opts_on, opts_off, *opts, opt, oind, ret, Dflag, Eflag, Iflag;
   WORD_LIST *l, *wl;
   COMPSPEC *cs;
 
-  opts_on = opts_off = Eflag = Dflag = 0;
+  opts_on = opts_off = Eflag = Dflag = Iflag = 0;
   ret = EXECUTION_SUCCESS;
 
   reset_internal_getopt ();
-  while ((opt = internal_getopt (list, "+o:DE")) != -1)
+  while ((opt = internal_getopt (list, "+o:DEI")) != -1)
     {
       opts = (list_opttype == '-') ? &opts_on : &opts_off;
 
@@ -817,6 +844,9 @@ compopt_builtin (list)
 	case 'E':
 	  Eflag = 1;
 	  break;
+	case 'I':
+	  Iflag = 1;
+	  break;
 	CASE_HELPOPT;
 	default:
 	  builtin_usage ();
@@ -825,8 +855,14 @@ compopt_builtin (list)
     }
   list = loptend;
 
-  wl = Dflag ? make_word_list (make_bare_word (DEFAULTCMD), (WORD_LIST *)NULL)
-	     : (Eflag ? make_word_list (make_bare_word (EMPTYCMD), (WORD_LIST *)NULL) : 0);
+  if (Dflag)
+    wl = make_word_list (make_bare_word (DEFAULTCMD), (WORD_LIST *)NULL);
+  else if (Eflag)
+    wl = make_word_list (make_bare_word (EMPTYCMD), (WORD_LIST *)NULL);
+  else if (Iflag)
+    wl = make_word_list (make_bare_word (INITIALWORD), (WORD_LIST *)NULL);
+  else
+    wl = (WORD_LIST *)NULL;
 
   if (list == 0 && wl == 0)
     {
--- a/doc/bash.1
+++ b/doc/bash.1
@@ -7452,12 +7452,12 @@ will be displayed.
 The return value is true unless an invalid option is supplied, or no
 matches were generated.
 .TP
-\fBcomplete\fP [\fB\-abcdefgjksuv\fP] [\fB\-o\fP \fIcomp-option\fP] [\fB\-DE\fP] [\fB\-A\fP \fIaction\fP] [\fB\-G\fP \fIglobpat\fP] [\fB\-W\fP \fIwordlist\fP] [\fB\-F\fP \fIfunction\fP] [\fB\-C\fP \fIcommand\fP]
+\fBcomplete\fP [\fB\-abcdefgjksuv\fP] [\fB\-o\fP \fIcomp-option\fP] [\fB\-DEI\fP] [\fB\-A\fP \fIaction\fP] [\fB\-G\fP \fIglobpat\fP] [\fB\-W\fP \fIwordlist\fP] [\fB\-F\fP \fIfunction\fP] [\fB\-C\fP \fIcommand\fP]
 .br
 [\fB\-X\fP \fIfilterpat\fP] [\fB\-P\fP \fIprefix\fP] [\fB\-S\fP \fIsuffix\fP] \fIname\fP [\fIname ...\fP]
 .PD 0
 .TP
-\fBcomplete\fP \fB\-pr\fP [\fB\-DE\fP] [\fIname\fP ...]
+\fBcomplete\fP \fB\-pr\fP [\fB\-DEI\fP] [\fIname\fP ...]
 .PD
 Specify how arguments to each \fIname\fP should be completed.
 If the \fB\-p\fP option is supplied, or if no options are supplied,
@@ -7472,6 +7472,12 @@ on a command for which no completion has
 The \fB\-E\fP option indicates that the remaining options and actions should
 apply to ``empty'' command completion; that is, completion attempted on a
 blank line.
+The \fB\-I\fP option indicates that the remaining options and actions should
+apply to completion on the inital non-assignment word on the line, or after
+a command delimiter such as \fB;\fP or \fB|\fP, which is usually command
+name completion.
+If multiple options are supplied, the \fB\-D\fP option takes precedence
+over \fB\-E\fP, and both take precedence of \fB\-I\fP.
 .sp 1
 The process of applying these completion specifications when word completion
 is attempted is described above under \fBProgrammable Completion\fP.
@@ -7661,7 +7667,7 @@ a \fIname\fP for which no specification
 an error occurs adding a completion specification.
 .RE
 .TP
-\fBcompopt\fP [\fB\-o\fP \fIoption\fP] [\fB\-DE\fP] [\fB+o\fP \fIoption\fP] [\fIname\fP]
+\fBcompopt\fP [\fB\-o\fP \fIoption\fP] [\fB\-DEI\fP] [\fB+o\fP \fIoption\fP] [\fIname\fP]
 Modify completion options for each \fIname\fP according to the
 \fIoption\fPs, or for the
 currently-executing completion if no \fIname\fPs are supplied.
@@ -7675,6 +7681,10 @@ on a command for which no completion has
 The \fB\-E\fP option indicates that the remaining options should
 apply to ``empty'' command completion; that is, completion attempted on a
 blank line.
+The \fB\-I\fP option indicates that the remaining options should
+apply to completion on the inital non-assignment word on the line,
+or after a command delimiter such as \fB;\fP or \fB|\fP, which is usually
+command name completion.
 .sp 1
 The return value is true unless an invalid option is supplied, an attempt
 is made to modify the options for a \fIname\fP for which no completion
--- a/pcomplete.h
+++ b/pcomplete.h
@@ -103,6 +103,7 @@ typedef struct _list_of_items {
 
 #define EMPTYCMD	"_EmptycmD_"
 #define DEFAULTCMD	"_DefaultCmD_"
+#define INITIALWORD	"_InitialWorD_"
 
 extern HASH_TABLE *prog_completes;
 extern int prog_completion_enabled;
