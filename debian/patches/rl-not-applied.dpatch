#! /bin/sh -e

echo "PATCHES WHICH ARE REPLACED UPSTREAM"
exit 1

if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
elif [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch $pdir -f --no-backup-if-mismatch -p1 < $0;;
    -unpatch) patch $pdir -f --no-backup-if-mismatch -R -p1 < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

--- bash-2.02.1.orig/lib/readline/tilde.c
+++ bash-2.02.1/lib/readline/tilde.c
@@ -47,9 +47,7 @@
 
 #include "tilde.h"
 
-#ifdef SHELL
 #include "shell.h"
-#endif
 
 #if !defined (HAVE_GETPW_DECLS)
 extern struct passwd *getpwuid (), *getpwnam ();
@@ -111,6 +109,8 @@
    `:' and `=~'. */
 char **tilde_additional_suffixes = default_suffixes;
 
+extern int rl_shell;
+
 /* Find the start of a tilde expansion in STRING, and return the index of
    the tilde which starts the expansion.  Place the length of the text
    which identified this tilde starter in LEN, excluding the tilde itself. */
@@ -171,14 +171,7 @@
   return (i);
 }
 
-#if !defined (SHELL)
-static char *
-get_string_value (varname)
-     char *varname;
-{
-  return ((char *)getenv (varname));
-}
-#endif
+extern char *get_env_value ();
 
 /* Return a new string which is the result of tilde expanding STRING. */
 char *
@@ -287,21 +280,13 @@
 static char *
 get_home_dir ()
 {
-  char *home_dir;
-
-#ifdef SHELL
-  home_dir = (char *)NULL;
-  if (current_user.home_dir == 0)
-    get_current_user_info ();
-  home_dir = current_user.home_dir;
-#else
+  /* this function will work whether rl_shell is set or not */
+  char *home_dir = "/";
   struct passwd *entry;
 
-  home_dir = (char *)NULL;
   entry = getpwuid (getuid ());
   if (entry)
     home_dir = entry->pw_dir;
-#endif
   return (home_dir);
 }
 
@@ -328,7 +313,7 @@
   if (filename[1] == '\0' || filename[1] == '/')
     {
       /* Prefix $HOME to the rest of the string. */
-      expansion = get_string_value ("HOME");
+      expansion = get_env_value ("HOME");
 
       /* If there is no HOME variable, look up the directory in
 	 the password database. */

--- bash-2.02.1.orig/lib/readline/readline.c
+++ bash-2.02.1/lib/readline/readline.c
@@ -179,6 +179,9 @@
 
 extern char *xmalloc (), *xrealloc ();
 
+void (*set_lines_and_columns_hook)() = 0;
+char* (*rl_get_string_value_hook)() = 0;
+
 /* **************************************************************** */
 /*								    */
 /*			Line editing input utility		    */
@@ -704,6 +713,11 @@
 static void
 readline_initialize_everything ()
 {
+  /* turn off rl_shell if not all the hooks were set (for older Debian
+     bash's) */
+  if (!set_lines_and_columns_hook || !rl_get_string_value_hook)
+    rl_shell = 0;
+
 #if defined (__EMX__)
   if (environ == 0)
     _emx_build_environ ();


--- bash-2.02.1.orig/lib/readline/complete.c
+++ bash-2.02.1/lib/readline/complete.c
@@ -251,6 +251,8 @@
 /* If non-zero, inhibit completion (temporarily). */
 int rl_inhibit_completion;
 
+extern int rl_shell;
+
 /* Variables local to this file. */
 
 /* Local variable states what happened during the last completion attempt. */
@@ -1026,11 +1028,10 @@
 			rl_filename_quoting_desired;
 
   if (should_quote)
-#if defined (SHELL)
-    should_quote = should_quote && (!qc || !*qc || *qc == '"' || *qc == '\'');
-#else /* !SHELL */
-    should_quote = should_quote && (!qc || !*qc);
-#endif /* !SHELL */
+    should_quote = should_quote &&
+      (rl_shell ?
+       (!qc || !*qc || *qc == '"' || *qc == '\'') :
+       (!qc || !*qc));
 
   if (should_quote)
     {
