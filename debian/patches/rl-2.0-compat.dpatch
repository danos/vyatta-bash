#! /bin/sh -e

if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
elif [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch $pdir -f --no-backup-if-mismatch -p1 < $0;;
    -unpatch) patch $pdir -f --no-backup-if-mismatch -R -p1 < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

# DP: <your description>

--- bash-2.02.1.orig/lib/readline/readline.c
+++ bash-2.02.1/lib/readline/readline.c
@@ -179,6 +179,11 @@
 
 extern char *xmalloc (), *xrealloc ();
 
+/* for backwards compatibility with version 2.0 */
+int (*char_is_quoted_hook)() = 0;
+char *(*double_quote_hook)() = 0;
+char *rl_vi_comment_begin = 0;
+
 /* **************************************************************** */
 /*								    */
 /*			Line editing input utility		    */

--- bash-2.02.1.orig/lib/readline/history.c
+++ bash-2.02.1/lib/readline/history.c
@@ -88,6 +88,13 @@
 /* The logical `base' of the history array.  It defaults to 1. */
 int history_base = 1;
 
+/* turn on shell mode */
+int history_shell = 0;
+char* (*history_get_string_value_hook)() = 0;
+
+/* for backwards compatibility with 2.0 */
+char* (*single_quote_hook)();
+
 /* Return the current HISTORY_STATE of the history. */
 HISTORY_STATE *
 history_get_history_state ()
@@ -125,6 +132,9 @@
 using_history ()
 {
   history_offset = history_length;
+  if (! history_get_string_value_hook)
+    history_shell = 0;		/* so won't try to call with older
+				   versions of bash */
 }
 
 /* Return the number of bytes that the primary history entries are using.

