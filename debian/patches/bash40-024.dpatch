#! /bin/sh -e

if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
elif [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch $pdir -f --no-backup-if-mismatch -p0 < $0;;
    -unpatch) patch $pdir -f --no-backup-if-mismatch -R -p0 < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

# DP: bash-4.0 upstream fix 024

			     BASH PATCH REPORT
			     =================

Bash-Release: 4.0
Patch-ID: bash40-024

Bug-Reported-by:  Matt Zyzik <matt.zyzik@nyu.edu>
Bug-Reference-ID:  <20090405205428.4FDEA1C7175@ice.filescope.com>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2009-04/msg00021.html

Bug-Description:

When using the ** globbing operator, bash will incorrectly add an extra
directory name when the preceding directory name ends with `*' or an empty
string when there is no preceding directory name.

Patch:

*** ../bash-4.0-patched/lib/glob/glob.c	2009-01-04 14:32:30.000000000 -0500
--- lib/glob/glob.c	2009-04-28 10:22:29.000000000 -0400
***************
*** 357,361 ****
        if (ep)
          *ep = 0;
!       if (r)
  	free (r);
        return (struct globval *)0;
--- 357,361 ----
        if (ep)
          *ep = 0;
!       if (r && r != &glob_error_return)
  	free (r);
        return (struct globval *)0;
***************
*** 666,671 ****
      }
  
!   /* compat: if GX_ALLDIRS, add the passed directory also */
!   if (add_current)
      {
        sdlen = strlen (dir);
--- 666,672 ----
      }
  
!   /* compat: if GX_ALLDIRS, add the passed directory also, but don't add an
!      empty directory name. */
!   if (add_current && (flags & GX_NULLDIR) == 0)
      {
        sdlen = strlen (dir);
***************
*** 679,686 ****
  	  nextlink->next = lastlink;
  	  lastlink = nextlink;
! 	  if (flags & GX_NULLDIR)
! 	    nextname[0] = '\0';
! 	  else
! 	    bcopy (dir, nextname, sdlen + 1);
  	  ++count;
  	}
--- 680,684 ----
  	  nextlink->next = lastlink;
  	  lastlink = nextlink;
! 	  bcopy (dir, nextname, sdlen + 1);
  	  ++count;
  	}
***************
*** 943,947 ****
  	      register unsigned int l;
  
! 	      array = glob_dir_to_array (directories[i], temp_results, flags);
  	      l = 0;
  	      while (array[l] != NULL)
--- 941,950 ----
  	      register unsigned int l;
  
! 	      /* If we're expanding **, we don't need to glue the directory
! 		 name to the results; we've already done it in glob_vector */
! 	      if ((dflags & GX_ALLDIRS) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
! 		array = temp_results;
! 	      else
! 		array = glob_dir_to_array (directories[i], temp_results, flags);
  	      l = 0;
  	      while (array[l] != NULL)
***************
*** 960,964 ****
  
  	      /* Note that the elements of ARRAY are not freed.  */
! 	      free ((char *) array);
  	    }
  	}
--- 963,968 ----
  
  	      /* Note that the elements of ARRAY are not freed.  */
! 	      if (array != temp_results)
! 		free ((char *) array);
  	    }
  	}
*** ../bash-4.0/patchlevel.h	2009-01-04 14:32:40.000000000 -0500
--- patchlevel.h	2009-02-22 16:11:31.000000000 -0500
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 23
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 24
  
  #endif /* _PATCHLEVEL_H_ */
